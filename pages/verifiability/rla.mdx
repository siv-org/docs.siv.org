---
part: Security Requirements → Verifiability
title: Risk Limiting Audits
---

## Why RLAs?

Risk Limiting Audits (RLAs) can provide an additional safeguard for election results, giving you the confidence that election results are accurate.

It is worth noting that even without RLAs, there is already strong basis for voters to trust that other voters will verify their vote using the Verification \#. Once an election outcome does not go their preferred way, supporters of the losing candidate have a strong incentive to verify that their vote was tallied correctly using their Verification #. SIV automatically stores all necessary verification materials on voters' device, so that they can still easily check their vote at any time without any prior preparation. If anything did go wrong, they have all the evidence needed to fully prove that their vote was not cast correctly.

However, using Risk Limiting Audits, we can achieve an even higher level of assurance of correct results.

## The Math Behind RLAs

Let's examine a concrete example. Imagine you participate in an election where you had the chance to cast your vote for one of two candidates: George Washington or Abraham Lincoln. You vote for Abraham Lincoln. But the final results show George Washington received 10 votes and Abraham Lincoln only 5.

Because your preferred candidate lost, you feel strongly motivated to confirm that the election results are accurate. What do you need to do to gain strong confidence?

You start by checking that the list of anonymized votes indeed adds up to 10 for Washington and 5 for Lincoln. Then you [check that your own Verification #](/verifiability/personal-vote) is in the list of anonymized votes, with your correct selection alongside it, and [confirm your own device wasn't manipulated by malware](/verifiability/multiple-devices). This tells you that at least 1 out of the 15 total votes is correct, but what about the other 14?

### An Unoptimized Process

**Do all of them need to be checked, or how many confirmations are needed to gain full confidence in the outcome?**

1. Because there were 15 votes, the majority needed to win is 8 votes (`round_up(15/2)`).
2. Considering the outcome was 10-to-5, if any 3 of the 10 Washington votes had been flipped from originally-Lincoln, the "true count" would have been 8 Lincoln to 7 Washington, changing the winner.
3. Thus, the margin of error is that 2 votes could have been flipped, without changing the final winner.
4. Therefore, I could be fully sure that the "true winner" won after **_confirmation from at least 13 voters_** (15 minus 2), who would confirm that they checked their vote was counted correctly, all without needing to compromise their privacy to know _how_ they voted.

Effectively, this approach requires approximately 75% of voters, rounded up, to be confident that no more than 25% of votes were flipped (the margin of error), and the winner truly had > 50% of the votes cast. This is a sort of "[naive](https://stackoverflow.com/questions/5700575/what-is-a-naive-algorithm-and-what-is-a-closed-form-solution)", unoptimized solution.

### Optimizing With Statistical Sampling Math

Rather than needing to check 13 out of 15 votes, if we use random statistical sampling, we can gain quite high confidence in the outcome, far more efficiently.

Continuing with our 10 Washington to 5 Lincoln example...

1. Our margin of error, as above, remains that at least 3 votes must have been flipped to change the final winner: `(winners_votes - runner_ups_votes) / 2`
2. Let us randomly sample just 1 out of the 15 voters, and confirm with the voter that their vote was included correctly in the final tally, without needing to learn _how_ they voted.
3. If the election was fraudulent, at least 3 of the votes must have been flipped, & 12 could remain as originally cast. So testing this first voter to confirm their vote was correct should "detect" if the election was fraudulent with probability 3 out of 15, or 20% of the time. In other words, just this single test can bring our confidence in a "correct" winner from 0% to 20%.
4. If we then randomly sample another voter, and they confirm their vote was counted correctly, this could have detected a cheating election with probability 3 out of 14: each test decreases the denominator by one.
5. The highest possible chance that our first sample did not catch present cheating was 80%, and the chance that the second sample alone did not is 11/14, or ~78.6%. But the chance that neither of them together did is `(12/15) * (11/14)`, or ~62.9%. So our overall confidence in correct results goes from 0% before any samples, to 20% after just 1 sample, to 37.1% after 2 samples.
6. A third sample can detect 3 out of the 13 remaining votes, and might fail to catch 10/13 times. So after three samples, the total "false positive" rate becomes `(12/15) * (11/14) * (10/13)`, or ~48.4%. So with just 3 samples, we've already gained over 51% confidence that the "correct" winner won.

Here is the basic formula continued for all 15 votes:

|  |  |  | this round |  | total |  |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| votes checked | possible frauds | # votes | chance of catching fraud | uncaught from this check | total uncaught chance | total confidence |
| 1 | 3 | 15 | 20% | 80% | 80% | 20.0% |
| 2 | 3 | 14 | 21.4% | 78.6% | 62.9% | 37.1% |
| 3 | 3 | 13 | 23% | 76.9% | 48.4% | 51.6% |
| 4 | 3 | 12 | 25% | 75.0% | 36.3% | 63.7% |
| 5 | 3 | 11 | 27% | 72.7% | 26.4% | 73.6% |
| 6 | 3 | 10 | 30% | 70.0% | 18.5% | 81.5% |
| 7 | 3 | 9 | 33% | 66.7% | 12.3% | 87.7% |
| 8 | 3 | 8 | 38% | 62.5% | 7.7% | 92.3% |
| 9 | 3 | 7 | 43% | 57.1% | 4.4% | 95.6% |
| 10 | 3 | 6 | 50% | 50% | 2.2% | 97.8% |
| 11 | 3 | 5 | 60% | 40% | 0.9% | 99.1% |
| 12 | 3 | 4 | 75% | 25% | 0.2% | 99.8% |
| 13 | 3 | 3 | 100% | 0% | 0.0% | 100.0% |
| 14 | 3 | 2 | 100% | 0% | 0.0% | 100.0% |
| 15 | 3 | 1 | 100% | 0% | 0.0% | 100.0% |

The power of an Risk Limiting Audit (RLA) is that you don't need to check all 15 votes. This RLA math shows that in this sample 15-vote election, just 3 random checks alone gives over 51% confidence, 6 checks gives over 81% confidence, and 8 checks give over 91% confidence.

### Deriving A General Formula

First, we'll note the specific closed form equation to make calculations much easier. Given an election's `total_votes_cast` & `margin_of_error` (difference between winner's votes & runner up's votes, divided by two), what % confidence is gained from confirming X randomly-sampled votes?

In the case of two votes checked in a 15 vote election with an error margin of 3, the "false positive" formula was `(12/15) * (11/14)`. This can be rewritten as `(12*11) / (15*14)`, or using [nCr format](https://en.wikipedia.org/wiki/Combination) as $\frac{12 \choose 2}{15 \choose 2}$.

This can be generalized for any election as:

`false_positive_rate = nChooseR(total_votes - margin_of_error, num_checked) / nChooseR(total_votes, num_checked)`

The confidence % is `1 - false_positive` rate.

### A Larger Example: The 2020 US Presidential Election in Georgia

Now that we have looked at how the math can work for this small 15 vote election, how does it scale for much larger elections?

The 2020 US Presidential Election in Georgia was remarkable for its razor-thin margin. The [certified final count](https://en.wikipedia.org/wiki/2020_United_States_presidential_election_in_Georgia) was:

|                        | #         | %      |
| ---------------------- | --------- | ------ |
| Total Votes Cast       | 4,999,958 | 100%   |
| Votes for Joe Biden    | 2,473,633 | 49.47% |
| Votes for Donald Trump | 2,461,854 | 49.24% |
|                        |           |        |
| Difference             | 11,779    |        |
| Margin of Error        | 5,889     | 0.12%  |

The margin of error was only 0.12%, meaning that only about 1 out of every 1000 votes would need to be compromised for a different winner.

Traditional paper elections do not offer voters a way to confirm that their individual vote was accurately counted. Although a different type of Risk-Limiting Audit, known as "Batch Comparison" RLAs, is encouraged and frequently used, it does not verify that the correct votes were counted in the first place ("Ballot-Level Comparison"). Instead, it confirms that the physical vote-tallying equipment worked properly. However, in the 2020 Georgia Election, the margin was too narrow to employ this type of RLA effectively. As a result, all 5 million ballots were manually recounted by hand across all 159 counties over a 10-day period. This constituted the largest hand count of ballots in United States history.

If individual ballots had been verifiable, as SIV allows, we can apply the closed form Risk Limiting Audit math above to calculate the following confidence gained:

| # Checked | % of total Checked | Confidence % Gained |
| --------- | ------------------ | ------------------- |
| 1         | 0.00%              | 0.12%               |
| 10        | 0.00%              | 1.17%               |
| 100       | 0.00%              | 11.12%              |
| 1000      | 0.02%              | 69.23%              |
| 5000      | 0.10%              | 99.72%              |
| 7500      | 0.15%              | 99.986%             |
| 10000     | 0.20%              | 99.9992%            |

<span className='text-sm'>
  [Code to re-calculate this table
  yourself](https://replit.com/@dsernst/RLAMath?v=1#index.ts)
</span>

As shown above, despite the razor thin margin, confirming only 5,000 randomly sampled votes out of the 4,999,958 total cast (about 1 in 1000) can provide 99.72% confidence that the final winner was correct. Doubling the amount checked to 10,000 out of the approximately 5,000,000 total votes results in 99.9992% confidence in correct outcomes.

This means that despite razor-thin margins, this form of individual ballot sampling can achieve very high confidence with high efficiency.

## Carrying Out a SIV RLA

A small sample size can be selected and reviewed by independent 3rd-party civil groups and official representatives, who can confirm with voters the integrity of their votes, without compromising the privacy of individual voters' selections.

notes:

- important to have a random sample
- using anti-malware codes

**Implementation Protocol**

1. The official conducting the audit should establish contact with the voter through an appropriate channel, usually a phone-call

1. The voter will be asked to self-verify the accuracy of their vote using the necessary tools — Verification # and if wanted a 2nd Device check — the voter will be guided through the process.

1. Upon completion of the verification process, the voter should inform the election official of the outcome, without disclosing the specifics of their vote. A statement such as "I have verified and confirmed that there are/are not any discrepancies" would suffice.

It is crucial that the protocol adopted does not compromise the sanctity of the secret ballot. In particular, the following approach should be avoided — the election official must not inquire about the specifics of the voter's choice, and the voter must not be asked to show evidence or otherwise disclose the candidate they voted for.

## Proving the Integrity of an RLA

_Zero-Knowledge Proof that a device cast a SIV vote_

If any particular device casts a vote in a SIV election, and that vote was accepted by the admin, the encrypted vote itself can now serve as a sort of public key for the device, with any of the Randomizers generated on device as private keys.

This allows a device to prove to anyone else that it has the key material that successfully voted in a particular election (e.g. already vetted by the election admin), and without revealing the underlying randomizers: i.e. create a signature to prove in Zero Knowledge.

For example, the voters participating in the Risk Limiting Audit will have clear proof that they are authenticated voters in that election and can show proof to the auditor who then can prove the integrity of the audit.

Technical Specification:

```
The encrypted vote is a series of ciphertexts, one for each votable item (e.g. Governor, mayor, Prop_2), each made up of two sub-parts.One of those two sub parts is named “lock”:

Lock = (Generator * randomizer)

Where:

- generator is the publicly known generator of the Ristretto group,
- randomizer is the random key material the device created, and
- * is elliptic curve point multiplication (a one way function)

This is enough of a public key to use for EdDSA or ECDSA signatures.

```
